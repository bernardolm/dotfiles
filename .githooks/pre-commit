#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

PYENV_ROOT="${PYENV_ROOT:-$HOME/.pyenv}"
if [ -x "$PYENV_ROOT/bin/pyenv" ]; then
	export PYENV_ROOT
	export PATH="$PYENV_ROOT/shims:$PYENV_ROOT/bin:$PATH"
	if [ -z "${PYENV_VERSION:-}" ] && [ -f ".python-version" ]; then
		PYENV_VERSION="$(head -n 1 .python-version | tr -d '[:space:]')"
		export PYENV_VERSION
	fi
fi

discard_v1_changes() {
	[ -d "$repo_root/.v1" ] || return 0
	git rev-parse --verify HEAD >/dev/null 2>&1 || return 0

	if ! git status --porcelain -- .v1 | grep -q .; then
		return 0
	fi

	echo "pre-commit: desfazendo alteracoes em .v1 com git checkout HEAD -- .v1"
	git checkout HEAD -- .v1

	if git status --porcelain -- .v1 | grep -q '^\?\? '; then
		echo "pre-commit: removendo nao rastreados em .v1"
		git clean -fd -- .v1 >/dev/null 2>&1 || true
	fi
}

discard_v1_changes

staged_python_files=()
staged_workflow_files=()
staged_added_files=()
staged_files=()
while IFS= read -r -d '' file; do
	staged_files+=("$file")
	case "$file" in
		*.py) staged_python_files+=("$file") ;;
		.github/workflows/*.yml|.github/workflows/*.yaml) staged_workflow_files+=("$file") ;;
	esac
done < <(git diff --cached --name-only --diff-filter=ACMR -z)

while IFS= read -r -d '' file; do
	staged_added_files+=("$file")
done < <(git diff --cached --name-only --diff-filter=A -z)

if [ "${#staged_files[@]}" -eq 0 ]; then
	exit 0
fi

run_python() {
	if command -v pyenv >/dev/null 2>&1; then
		pyenv exec python "$@"
		return $?
	fi
	if command -v python3 >/dev/null 2>&1; then
		python3 "$@"
		return $?
	fi
	if command -v python >/dev/null 2>&1; then
		python "$@"
		return $?
	fi
	echo "pre-commit: erro: python nao encontrado para executar tarefas do hook." >&2
	return 1
}

validate_workflow_policies() {
	local invalid=0
	local file=""

	for file in "${staged_workflow_files[@]-}"; do
		[ -f "$file" ] || continue
		if ! rg -q "\\.v1/\\*\\*|\\.v1/" "$file"; then
			echo "pre-commit: erro: workflow sem exclusao explicita de .v1: $file"
			invalid=1
		fi
	done

	if [ "$invalid" -ne 0 ]; then
		echo "pre-commit: adicione 'paths-ignore' com '.v1/**' no(s) workflow(s) acima."
		return 1
	fi
	return 0
}

is_shell_script_file() {
	local file="$1"
	local first_line=""

	case "$file" in
		*.sh|*.bash|*.zsh|*.ksh) return 0 ;;
	esac

	[ -f "$file" ] || return 1
	first_line="$(head -n 1 "$file" 2>/dev/null || true)"
	[[ "$first_line" =~ ^#! ]] || return 1
	[[ "$first_line" =~ (sh|bash|zsh|ksh) ]] || return 1
	return 0
}

validate_new_shell_scripts_policy() {
	local invalid=0
	local file=""

	for file in "${staged_added_files[@]-}"; do
		[ -f "$file" ] || continue
		if ! is_shell_script_file "$file"; then
			continue
		fi
		if ! head -n 30 "$file" | rg -q "shell-required:"; then
			echo "pre-commit: erro: novo script shell sem justificativa tecnica: $file"
			invalid=1
		fi
	done

	if [ "$invalid" -ne 0 ]; then
		echo "pre-commit: regra ativa: novos scripts devem ser Python por padrao."
		echo "pre-commit: use shell so quando necessario e adicione no topo do arquivo:"
		echo "pre-commit:   # shell-required: <motivo tecnico de por que Python nao atende bem>"
		return 1
	fi
	return 0
}

validate_workflow_policies
validate_new_shell_scripts_policy

normalized_files=()
while IFS= read -r changed_file; do
	[ -n "$changed_file" ] || continue
	normalized_files+=("$changed_file")
done < <(run_python "$repo_root/bin/normalize_tabs.py")

if [ "${#normalized_files[@]}" -gt 0 ]; then
	echo "pre-commit: indentacao (qualquer nivel) normalizada para tabs em ${#normalized_files[@]} arquivo(s)."
fi

if [ "${#staged_python_files[@]}" -gt 0 ]; then
	echo "pre-commit: ajustando ${#staged_python_files[@]} arquivo(s) Python..."

	run_python "$repo_root/bin/pre_commit_ensure_python_tools.py"
	run_python "$repo_root/bin/pre_commit_run_python_tools.py"
fi

git add -- "${staged_files[@]}"
echo "pre-commit: ajustes aplicados e adicionados ao stage."
